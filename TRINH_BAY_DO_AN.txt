1. BÁO CÁO TRÌNH BÀY - NHỮNG GIẢI PHÁP KỸ THUẬT THÚ VỊ TRONG DỰ ÁN

1.1 Tổng quan
----------
1.1.1 Mục tiêu
File này tóm tắt và giải thích các đoạn code/giải pháp kỹ thuật đáng chú ý trong repository: một web server tĩnh đa luồng và các công cụ kiểm thử đi kèm.

1.1.2 Phạm vi
Tập trung giải thích các phần kỹ thuật phức tạp như logger thread-safe, cơ chế đa luồng, bảo vệ path traversal, API nội bộ, mô phỏng lỗi và client test để stress-test server.

1.2 Luồng xử lý request (mô tả ngắn)
1.2.1 Bước 1 - Server accept: Server lắng nghe ở cổng cấu hình, accept kết nối.
1.2.2 Bước 2 - Đọc và parse request: Đọc header, parse method và đường dẫn.
1.2.3 Bước 3 - Mô phỏng lỗi (nếu bật): Kiểm tra `can_that_bai()` để biết có trả lỗi mô phỏng thay vì xử lý.
1.2.4 Bước 4 - Xử lý API hoặc file: Nếu đường dẫn bắt đầu bằng `/api/`, gọi hàm xử lý API; nếu không, kiểm tra path traversal rồi trả file từ `public/`.
1.2.5 Bước 5 - Ghi log & gửi response: Viết log kết quả và gửi header + nội dung (hoặc chỉ header nếu HEAD).
Giải thích: Mục này cho người đọc biết dòng thời gian (sequence) cơ bản của một request.

2. Logger thread-safe và quản lý log
------------------------------------------------------
2.1 Vấn đề
2.1.1 Khi nhiều worker xử lý request đồng thời, ghi log có thể bị trộn lẫn hoặc gây race condition; file log có thể tăng kích thước vô hạn.

2.2 Giải pháp (File: `server.py` - `ThreadSafeLogger`)
2.2.1 RotatingFileHandler
- Sử dụng `RotatingFileHandler` để giới hạn kích thước file (maxBytes, backupCount) giúp tránh ghi log vô hạn.
2.2.2 StreamHandler
- Thêm `StreamHandler` để xuất log ra console, thuận tiện cho debug trực tiếp.
2.2.3 Lock và buffer
- Dùng `threading.Lock()` để bảo vệ thao tác ghi log và cập nhật `log_buffer` (in-memory, tối đa 500 dòng) để API `/api/logs` trả về.

2.2.4 Snippet minh họa (tóm tắt):
```
class ThreadSafeLogger:
	def __init__(self, log_file):
		self._lock = threading.Lock()
		self.log_buffer = []  # store recent log messages
	def info(self, msg):
		with self._lock:
			self.logger.info(msg)
			self.log_buffer.append(msg)
```
Giải thích: `with self._lock` đảm bảo rằng chỉ 1 thread ghi log tại một thời điểm, tránh nội dung bị lẫn nhau.

2.3 Lợi ích
- Đảm bảo an toàn khi ghi log trong môi trường đa luồng; vừa lưu vào file vừa có bộ nhớ đệm để trả log nhanh.

2.4 Gợi ý nâng cao
- Dùng `collections.deque` cho `log_buffer` để tối ưu pop/push.
- Triển khai log queue + dedicated logging thread để tránh block I/O trong thread worker.

3. HTTP Server đa luồng (ThreadPoolExecutor)
------------------------------------------------
3.1 Yêu cầu
3.1.1 Hỗ trợ nhiều client đồng thời, xử lý request nhanh và an toàn, có kết thúc mượt mà (graceful shutdown).

3.2 Giải pháp
3.2.1 ThreadPoolExecutor
- Sử dụng `ThreadPoolExecutor` để phân phát mỗi kết nối tới worker thread có sẵn, giới hạn số lượng threads thông qua `max_workers`.
3.2.2 Loop accept() với timeout
- Đặt `server_socket.settimeout(1)` để vòng accept kiểm tra cờ `_running` và có thể dừng nhanh.
3.2.3 Signal handler cho shutdown
- `signal.signal(SIGINT/SIGTERM)` để set event `self._shutdown_event`, thay đổi `_running` và thực thi `executor.shutdown(wait=True)`.

3.2.4 Snippet minh họa (vòng accept):
```
while self._running:
	try:
		sock, addr = self.server_socket.accept()
		self.executor.submit(self.xu_ly_client, sock, addr)
	except socket.timeout:
		continue
```
Giải thích: `accept()` có timeout để vòng lặp có thể kiểm tra cờ `_running`, giúp server tắt mượt (graceful shutdown) khi nhận SIGINT/SIGTERM.

Chú ý: Nếu không đặt timeout, `accept()` sẽ block vô thời hạn và server sẽ khó phản ứng để tắt mượt.

3.3 Lợi ích
- Tránh tạo thread không kiểm soát; shutdown mượt mà cho phép hoàn tất tác vụ hiện tại.

3.4 Gợi ý nâng cao
- Thêm giới hạn kết nối (queue) hoặc từ chối khi pool đầy.
- Cân nhắc async I/O (asyncio, sanic, uvicorn) nếu cần scale lên nhiều kết nối I/O-bound.

4. Bảo vệ path traversal và MIME type detection
------------------------------------------------
4.1 Mô tả vấn đề
4.1.1 Kẻ tấn công có thể tấn công path traversal bằng `../`, truy cập file hệ thống ngoài `public/` nếu không kiểm tra cẩn thận.
Ví dụ: `GET /../../etc/passwd` (Linux) có thể lộ file nhạy cảm nếu server không kiểm tra đường dẫn.

4.2 Giải pháp
4.2.1 Sử dụng `Path.resolve()` và `relative_to()`
- Xây dựng đường dẫn tuyệt đối `full_path = (self.public_dir / file_path).resolve()`;
- Kiểm tra `full_path.relative_to(self.public_dir.resolve())` nếu lỗi => path traversal -> 403 Forbidden.

4.2.1.1 Snippet `khoa_yen_to` (rút gọn):
```
def khoa_yen_to(self, file_path):
	full_path = (self.public_dir / file_path.lstrip('/')).resolve()
	full_path.relative_to(self.public_dir.resolve())  # sẽ raise nếu không thuộc public
	return True
```
Giải thích: `resolve()` chuyển thành đường dẫn tuyệt đối; `relative_to()` kiểm tra ràng buộc trong `public_dir`.
4.2.2 MIME detection
- Dùng `MIME_TYPES` mapping; fallback sang `mimetypes.guess_type()`; nếu không tìm thấy -> `application/octet-stream`.

4.3 Lợi ích
- Giảm thiểu rủi ro path traversal, đảm bảo server chỉ trả file trong thư mục `public/`.

5. API nội bộ cho lưu test-results và logs
-----------------------------------------
5.1 Endpoints
5.1.1 POST `/api/test-results`
- Nhận JSON payload từ client (test client), parse, lưu vào `self.test_results` (lock bảo vệ).
5.1.2 GET `/api/test-results`
- Trả JSON các kết quả test hiện có.
5.1.3 GET `/api/logs`
- Trả `self.logger.log_buffer` (log gần nhất) dưới dạng JSON.

5.2 Thread-safety
- Sử dụng `self._results_lock` khi ghi `self.test_results`, `self.logger._lock` khi lấy `log_buffer`.

5.3 Use cases
- Hỗ trợ tích hợp test tự động, console monitoring hoặc gửi kết quả từ CI/CD.

5.4 Ví dụ sử dụng (client)
```
# POST /api/test-results
# Body: {"timestamp": "2025-12-11T...", "total_requests": 20, "results": [{...}, ...]}
```
Giải thích: Client test gửi kết quả dạng JSON để server lưu và cung cấp lại qua API.
Ví dụ POST (tóm tắt):
```
POST /api/test-results HTTP/1.1
Host: 127.0.0.1:5000
Content-Type: application/json
Content-Length: ...

{ "timestamp": "...", "total_requests": 20, "results": [...] }
```

Ví dụ response JSON (server trả về sau khi nhận thành công):
```
{ "success": true, "message": "Đã lưu kết quả test", "count": 20 }
```

6. Mô phỏng lỗi (Failure Simulation)
-----------------------------------
6.1 Mục đích
- Mô phỏng lỗi ngẫu nhiên để kiểm thử resilience của client và hệ thống (timeout, HTTP errors).

6.2 Cách hoạt động
6.2.1 `enable_failure_simulation` + `failure_rate`
- Nếu bật, hàm `can_that_bai()` trả true dựa trên `random.random()` < `failure_rate`.
6.2.2 `loi_that_bai_ngau_nhien()`
- Chọn ngẫu nhiên một mã lỗi (500, 503, 504) và gửi response tương ứng.

6.2.3 Ví dụ hành vi
- Nếu `failure_rate` = 0.2 và `enable_failure_simulation` = True → khoảng 20% request sẽ nhận lỗi (500/503/504) do mô phỏng, giúp kiểm tra khả năng retry/backoff của client.

6.3 Lợi ích
- Test điều kiện lỗi, validate client behavior (retry, timeout, backoff).

7. Client test đồng thời và gửi kết quả chấm điểm
---------------------------------------------------
7.1 Thiết kế
7.1.1 `HTTPClient` là client thử nghiệm dùng `socket` + `ThreadPoolExecutor`.
7.1.2 Tạo nhiều request song song, ghi nhận response, sau đó gửi tập kết quả lên `/api/test-results`.

7.1.3 Snippet ví dụ (đo latency):
```
import time
start = time.time()
# gửi request
duration_ms = (time.time() - start) * 1000
```
Giải thích: Mỗi request được đo thời gian để tính latency/throughput.

7.2 Metrics thu thập
- Mã trạng thái (status_code), thời gian phản hồi (response_time), kích thước nội dung (content_length), lỗi (error), success flag.

7.3 Reporting
- Sau khi test, client gửi POST JSON tổng hợp đến server; server lưu và có thể trả lại để phân tích.

8. Một số gợi ý, cải tiến tương lai
-------------------------------
8.1 Streaming và hiệu suất
- Hiện server đọc toàn file vào memory trước khi gửi; cho file lớn, chuyển sang streaming (chunked) hoặc `os.sendfile` để giảm bộ nhớ.

8.2 Bảo mật
- Thực hiện TLS/HTTPS, kiểm soát header, hạn chế HSTS, rate-limiting, và các kiểm tra xác thực nếu cần.

8.3 Tăng khả năng mở rộng
- Cân nhắc load-balancer / multiple processes / async frameworks để xử lý số lượng kết nối lớn hơn.

8.4 Giám sát
- Tích hợp Prometheus/metrics endpoint để theo dõi latency, throughput, error rates.

8.5 Hướng dẫn chạy & kiểm thử (tóm tắt)
- Chạy server (powershell):
```
python server.py
```
- Chạy client test (gửi nhiều request):
```
python client_test.py
```
- Lấy logs via API: `python test_api.py` (hoặc curl/HTTP client)

8.6 Thuật ngữ ngắn (tự giải thích):
- ThreadPoolExecutor: một pool các worker threads dùng để chạy nhiệm vụ đồng thời mà không tạo thread mới mỗi lần.
- RotatingFileHandler: trình ghi log tự xoay vòng (khi đạt max size sẽ tạo file mới), tránh file log quá lớn.
- Path.resolve/relative_to: kỹ thuật kiểm tra để đảm bảo file trả về nằm trong thư mục `public/`.

9. Kết luận
--------
9.1 Tổng kết
Dự án có các giải pháp kỹ thuật gọn và hữu dụng để triển khai web server tĩnh đa luồng ở mức độ nhỏ-vừa, kèm hệ thống test tích hợp và mô phỏng lỗi. Các điểm nổi bật gồm logger thread-safe, bảo vệ path traversal, thread pool handling và API dành cho test-results/logs.

9.2 Hướng phát triển
Có thể mở rộng bằng streaming file, async I/O, TLS/HTTPS, và tích hợp metrics/monitoring để đưa ứng dụng lên môi trường production.

---
Nhóm có thể bổ sung các hình vẽ kiến trúc (có sẵn `KienTrucHeThong.drawio`) và phần hướng dẫn chạy (README) để báo cáo chi tiết hơn.